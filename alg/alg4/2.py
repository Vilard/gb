# 2. Написать два алгоритма нахождения i-го по счёту простого числа.
# Без использования «Решета Эратосфена»;
# Используя алгоритм «Решето Эратосфена»
# Примечание ко всему домашнему заданию: Проанализировать скорость и сложность алгоритмов. Результаты анализа сохранить в виде комментариев в файле с кодом

import time

num = 1
lenrange = 250
r = list(range(lenrange+1))
# без решета
#=========================================
def IsPrime(n):
    d = 2
    for _i in r:
        if n % d != 0:
            d += 1
    return d == n

def get_element(i):
    arr = []
    for k in r:
        if IsPrime(k):
            arr.append(k)
    return arr[i-1]


# с решетом
#=========================================

def f2 (i):
    arr = []
    a, n = True, lenrange
    for x in range(2,n):
        for y in range(1,n):
            if x != y and y != 1:
                if not x % y:
                    a = False
                    break
        if a == True:
            arr.append(x)
        a = True
    return arr[i-1]

#=========================================


start = time.time()
get_element(num)
stop = time.time()

print(stop-start, get_element(num))

start = time.time()
f2(num)
stop = time.time()

print(stop-start, f2(num))


# get_element(i) O(n)
# f2(i) O(n)
# на самом деле не совсем уверен в результате, исполнение кода с решетом получаеться быстрее примерно 2 раза, при прогоне на разных величинах массива получаеться в первом случае квадратичная зависимость 
# О(n в квадрате).
#  во втором случае увеличение происходит на 1.7 примерно зависимость похожа на линейную, но скорее логорифмическая или O(sqrt(n)), но вроде как должно быть O(n), то есть линейная. 